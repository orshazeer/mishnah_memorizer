<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
 <title>Mishnah Fluency Pro</title>
 <style>
 :root {
 --bg: #0f172a;
 --surface: #1e293b;
 --surface-hover: #334155;
 --primary: #38bdf8;
 --accent: #fbbf24;
 --error: #f43f5e;
 --success: #10b981;
 --text: #f1f5f9;
 --text-dim: #94a3b8;
 --modal-bg: rgba(15, 23, 42, 0.95);
 --highlight-yellow: rgba(254, 240, 138, 0.6); 
 }

 body {
 background-color: var(--bg);
 color: var(--text);
 font-family: 'Inter', 'SBL Hebrew', system-ui, sans-serif;
 display: flex; flex-direction: column; height: 100vh; margin: 0; overflow: hidden;
 touch-action: manipulation;
 }

 #top-bar {
 width: 100%; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center;
 box-sizing: border-box; z-index: 10; background: var(--surface); flex-shrink: 0;
 }

 .btn-group { display: flex; gap: 8px; align-items: center; }
 .btn {
 background: var(--bg); border: 1px solid var(--surface-hover); color: var(--text);
 padding: 8px 14px; border-radius: 10px; cursor: pointer; font-size: 13px; font-weight: 600;
 transition: 0.2s;
 }
 .btn:hover { background: var(--surface-hover); border-color: var(--primary); }
 .btn.active-mode { background: var(--surface-hover); border-color: var(--accent); color: var(--accent); }

 #main-scroll-container {
 flex: 1; overflow-y: auto; display: flex; flex-direction: column; align-items: center;
 padding: 20px; scroll-behavior: smooth;
 }

 #status-container { text-align: center; margin-bottom: 20px; width: 100%; flex-shrink: 0; }
 #status { color: var(--primary); font-size: 14px; font-weight: 700; cursor: pointer; }
 #instructions { color: var(--text); font-size: 32px; font-weight: 700; margin-bottom: 2px; }
 #sub-instructions { color: var(--accent); font-size: 14px; font-weight: 500; height: 20px; }

 #display-area {
 width: 95%; min-height: 120px; display: flex; flex-wrap: wrap;
 justify-content: center; align-items: center; text-align: center;
 pointer-events: none; margin-bottom: 50px;
 }

 #bart-container {
 width: 100%; height: 280px; flex-shrink: 0; background: #0a0f1e; 
 border-top: 3px solid var(--primary); box-sizing: border-box;
 display: none; z-index: 5; overflow-y: auto; padding: 0;
 }

 #bart-content { 
 font-size: 1.25rem; line-height: 1.8; color: #ffffff; width: 100%; 
 text-align: right; padding: 20px 40px; box-sizing: border-box;
 }

 .bart-segment { display: inline; cursor: pointer; }
 .bart-segment b { color: var(--primary); font-weight: 900; }
 .explanation { padding: 2px 6px; border-radius: 4px; transition: background-color 0.2s; }

 .active-highlight .explanation {
 background-color: var(--highlight-yellow);
 color: #000000; 
 }

 .chunk-mode { font-size: 58px; font-weight: 700; line-height: 1.2; }
 .full-mode { font-size: 36px; font-weight: 500; gap: 10px; line-height: 1.4; }
 .word { padding: 2px 4px; border-radius: 6px; }
 .wrong-word { background: rgba(244, 63, 94, 0.2); color: var(--error); text-decoration: line-through; }
 
 /* HINT STYLE */
 .hint-word { color: var(--accent); font-style: italic; opacity: 0.8; font-weight: bold; }

 /* FIRST WORD REVIEW STYLES */
 .fw-container { display: flex; flex-direction: column; gap: 15px; width: 100%; align-items: center; }
 .fw-item { font-size: 32px; font-weight: 600; color: var(--text); animation: fadeIn 0.3s ease; }
 .fw-separator { width: 100%; text-align: center; color: var(--text-dim); margin: 20px 0; font-size: 14px; border-bottom: 1px solid var(--surface-hover); line-height: 0.1em; }
 .fw-separator span { background: var(--bg); padding: 0 10px; }
 @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }


 #progress-pips { margin-top: 10px; display: flex; gap: 8px; justify-content: center; }
 .pip { width: 25px; height: 4px; background: var(--surface-hover); border-radius: 10px; transition: 0.4s; }
 .pip.active { background: var(--primary); width: 40px; }
 .pip.complete { background: var(--success); }

 #mobile-back {
 position: fixed; bottom: 300px; left: 30px; width: 60px; height: 60px;
 border-radius: 50%; background: var(--surface); border: 2px solid var(--primary);
 color: var(--primary); display: none; align-items: center; justify-content: center;
 font-size: 24px; z-index: 100;
 }

 #nav-modal {
 display: none; position: fixed; inset: 0; background: var(--modal-bg);
 backdrop-filter: blur(12px); z-index: 1000; align-items: center; justify-content: center;
 }
 .nav-card { background: var(--surface); width: 600px; max-width: 95%; height: 500px; border-radius: 20px; border: 1px solid var(--surface-hover); display: flex; flex-direction: column; overflow: hidden; }
 .nav-header { padding: 15px; border-bottom: 1px solid var(--surface-hover); display: flex; justify-content: space-between; }
 .nav-body { flex: 1; padding: 15px; overflow-y: auto; }
 .grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(55px, 1fr)); gap: 10px; }
 .grid-item { background: var(--bg); border: 1px solid var(--surface-hover); border-radius: 8px; height: 45px; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; }
 .list-item { padding: 10px 14px; border-radius: 8px; background: rgba(255,255,255,0.03); cursor: pointer; display: flex; justify-content: space-between; margin-bottom: 6px; }
 #masechet-search { background: transparent; border: none; border-bottom: 2px solid var(--surface-hover); color: var(--text); font-size: 20px; padding: 8px 0; width: 100%; margin-bottom: 15px; outline: none; }
 .hidden { display: none !important; }
 </style>
</head>
<body onload="autoDetectPlatform()" onclick="handleGlobalClick(event)">

 <div id="top-bar">
 <div class="btn-group">
 <button class="btn" onclick="openNav(); event.stopPropagation();">üìö Navigator</button>
 <button class="btn" onclick="handleReset(event)">üîÑ Reset</button>
 <button id="loop-btn" class="btn" onclick="toggleLoopMode(event)">‚àû Review</button>
 </div>
 <div class="btn-group">
 <button id="fw-btn" class="btn" onclick="toggleFirstWordMode(event)">1st Words</button>
 <button class="btn" onclick="toggleLanguage(); event.stopPropagation();">üåê EN/HE</button>
 </div>
 </div>

 <div id="main-scroll-container">
    <div id="status-container">
        <div id="status" onclick="openNav()">Select Mishnah</div>
        <div id="instructions">Mishnah Fluency</div>
        <div id="sub-instructions">Loading...</div>
        <div id="progress-pips"></div>
    </div>
    <div id="display-area"></div>
 </div>

 <div id="bart-container"><div id="bart-content"></div></div>
 <div id="mobile-back" onclick="triggerCorrection(event)">‚Ü©</div>

 <div id="nav-modal" onclick="if(event.target===this) closeNav()">
 <div class="nav-card" onclick="event.stopPropagation()">
 <div class="nav-header"><span id="nav-step-title">Select Masechet</span><button class="btn" onclick="closeNav()">‚úï</button></div>
 <div class="nav-body">
 <div id="step-masechet"><input type="text" id="masechet-search" placeholder="Search..."><div id="masechet-list"></div></div>
 <div id="step-perek" class="hidden"><button class="btn" onclick="backToMasechet()">‚Üê Back</button><div id="perek-grid" class="grid-container" style="margin-top:15px;"></div></div>
 <div id="step-mishnah" class="hidden"><button class="btn" onclick="backToPerek()">‚Üê Back</button><div id="mishnah-grid" class="grid-container" style="margin-top:15px;"></div></div>
 </div>
 </div>
 </div>

 <script>
 // --- AUTO-DETECTION LOGIC ---
 function autoDetectPlatform() {
    const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    const isSmallScreen = window.innerWidth <= 1024; 
    
    if (isTouch || isSmallScreen) {
        isMobile = true;
        document.body.classList.add('is-mobile');
        document.getElementById('mobile-back').style.display = 'flex';
    } else {
        isMobile = false;
    }
    openNav();
 }

 const masechtotData = [
 { en: "Berakhot", he: "◊ë◊®◊õ◊ï◊™", file: "Berakhot" }, { en: "Peah", he: "◊§◊ê◊î", file: "Peah" }, { en: "Demai", he: "◊ì◊û◊ê◊ô", file: "Demai" }, { en: "Kilayim", he: "◊õ◊ú◊ê◊ô◊ô◊ù", file: "Kilayim" }, { en: "Sheviit", he: "◊©◊ë◊ô◊¢◊ô◊™", file: "Sheviit" }, { en: "Terumot", he: "◊™◊®◊ï◊û◊ï◊™", file: "Terumot" }, { en: "Maaserot", he: "◊û◊¢◊©◊®◊ï◊™", file: "Maaserot" }, { en: "Maaser Sheni", he: "◊û◊¢◊©◊® ◊©◊†◊ô", file: "Maaser_Sheni" }, { en: "Challah", he: "◊ó◊ú◊î", file: "Challah" }, { en: "Orlah", he: "◊¢◊®◊ú◊î", file: "Orlah" }, { en: "Bikkurim", he: "◊ë◊ô◊õ◊ï◊®◊ô◊ù", file: "Bikkurim" }, { en: "Shabbat", he: "◊©◊ë◊™", file: "Shabbat" }, { en: "Eruvin", he: "◊¢◊ô◊®◊ï◊ë◊ô◊ü", file: "Eruvin" }, { en: "Pesachim", he: "◊§◊°◊ó◊ô◊ù", file: "Pesachim" }, { en: "Sheqalim", he: "◊©◊ß◊ú◊ô◊ù", file: "Sheqalim" }, { en: "Yoma", he: "◊ô◊ï◊û◊ê", file: "Yoma" }, { en: "Sukkah", he: "◊°◊ï◊õ◊î", file: "Sukkah" }, { en: "Beitzah", he: "◊ë◊ô◊¶◊î", file: "Beitzah" }, { en: "Rosh Hashanah", he: "◊®◊ê◊© ◊î◊©◊†◊î", file: "Rosh_Hashanah" }, { en: "Taanit", he: "◊™◊¢◊†◊ô◊™", file: "Taanit" }, { en: "Megillah", he: "◊û◊í◊ô◊ú◊î", file: "Megillah" }, { en: "Moed Katan", he: "◊û◊ï◊¢◊ì ◊ß◊ò◊ü", file: "Moed_Katan" }, { en: "Chagigah", he: "◊ó◊í◊ô◊í◊î", file: "Chagigah" }
 ];

 let tractate = [], bartenuraData = "", rawTextCache = "", currentTractateName = "", currentTractateHebrew = "";
 let pIdx = 0, mIdx = 0, sIdx = 0, cIdx = 0, wIdx = -1, isMobile = false;
 let displayState = "CHUNKS", currentLang = 'en';
 let correctionTarget = -1, correctionSentenceIdx = -1, returnState = "";
 
 // STATE VARIABLES
 let showHint = false;
 let isLoopMode = false;
 let isFirstWordMode = false;
 let fwHistory = []; // Stores history for First Word Mode

 const content = {
 en: { steps: { CHUNKS: "Learn Chunks", FULL_SENTENCE: "Read Full", SENTENCE_REVIEW: "Recite", CUMULATIVE_REVIEW: "Mastery", CORRECTING: "Correction", FW: "Mishnah Heads" }, subs: { CHUNKS: "Tap/Space to advance", FULL_SENTENCE: "Read full sentence", SENTENCE_REVIEW: "Say next word", CUMULATIVE_REVIEW: "Recite from start", CORRECTING: "Repeat highlighted word", FW: "Space for next Mishnah" } },
 he: { steps: { CHUNKS: "◊ú◊ô◊û◊ï◊ì ◊û◊ß◊ò◊¢◊ô◊ù", FULL_SENTENCE: "◊ß◊®◊ô◊ê◊î ◊û◊ú◊ê◊î", SENTENCE_REVIEW: "◊©◊ô◊†◊ï◊ü", CUMULATIVE_REVIEW: "◊ó◊ñ◊®◊î", CORRECTING: "◊™◊ô◊ß◊ï◊ü", FW: "◊®◊ê◊©◊ô ◊û◊©◊†◊ô◊ï◊™" }, subs: { CHUNKS: "◊í◊¢/◊®◊ï◊ï◊ó ◊ú◊î◊™◊ß◊ì◊û◊ï◊™", FULL_SENTENCE: "◊ß◊®◊ê ◊û◊©◊§◊ò ◊û◊ú◊ê", SENTENCE_REVIEW: "◊ê◊û◊ï◊® ◊û◊ô◊ú◊î ◊î◊ë◊ê◊î", CUMULATIVE_REVIEW: "◊ó◊ñ◊ï◊® ◊û◊î◊î◊™◊ó◊ú◊î", CORRECTING: "◊ó◊ñ◊ï◊® ◊¢◊ú ◊î◊û◊ô◊ú◊î ◊î◊û◊°◊ï◊û◊†◊™", FW: "◊®◊ï◊ï◊ó ◊ú◊û◊©◊†◊î ◊î◊ë◊ê◊î" } }
 };

 function getHebrewLetter(num) {
    const letters = ["◊ê","◊ë","◊í","◊ì","◊î","◊ï","◊ñ","◊ó","◊ò","◊ô","◊ô◊ê","◊ô◊ë","◊ô◊í","◊ô◊ì","◊ò◊ï","◊ò◊ñ","◊ô◊ñ","◊ô◊ó","◊ô◊ò","◊õ"];
    return letters[num] || num;
 }

 function handleGlobalClick(e) {
    if (document.getElementById('nav-modal').style.display === "flex") return;
    if (e.target.closest('.btn') || e.target.closest('#mobile-back') || e.target.closest('input')) return;

    const segment = e.target.closest('.bart-segment');
    if (segment) {
        e.stopPropagation();
        document.querySelectorAll('.bart-segment').forEach(s => s.classList.remove('active-highlight'));
        segment.classList.add('active-highlight');
        return;
    }

    document.querySelectorAll('.bart-segment').forEach(s => s.classList.remove('active-highlight'));
    handleAdvance();
 }

 function handleAdvance() {
    showHint = false;
    if (!tractate.length) return;

    if (isFirstWordMode) {
        advanceFirstWordMode();
        return;
    }

    const curM = tractate[pIdx][mIdx];
    const curS = curM.sentences[sIdx];

    if (displayState === "CHUNKS") {
        if (cIdx < curS.chunks.length - 1) cIdx++;
        else { displayState = "SENTENCE_REVIEW"; wIdx = -1; }
    } else if (displayState === "FULL_SENTENCE") {
        displayState = "SENTENCE_REVIEW"; wIdx = -1;
    } else if (displayState === "SENTENCE_REVIEW") {
        if (wIdx < curS.words.length - 1) wIdx++;
        else {
            if (isLoopMode) advanceMishnahPosition();
            else sIdx === 0 ? advanceMishnahPosition() : (displayState = "CUMULATIVE_REVIEW", wIdx = -1);
        }
    } else if (displayState === "CUMULATIVE_REVIEW") {
        const total = curM.sentences.slice(0, sIdx + 1).reduce((a,b)=>a+b.words.length, 0);
        if (wIdx < total - 1) { wIdx++; } 
        else {
            if (isLoopMode) wIdx = -1;
            else advanceMishnahPosition();
        }
    } else if (displayState === "CORRECTING") {
        if (wIdx < correctionTarget) wIdx++; 
        else { displayState = returnState; wIdx = -1; }
    }
    updateDisplay();
 }

 function advanceFirstWordMode() {
    // Determine next Mishnah coordinates
    if (!tractate[pIdx][mIdx]) return;
    
    // Get the first word of CURRENT target
    const word = tractate[pIdx][mIdx].sentences[0].words[0];
    
    // Check if we just started a new perek (mIdx was 0) to add separator
    if (mIdx === 0 && pIdx > 0 && fwHistory.length > 0) {
        // Only add if last item wasn't already a separator
        if (fwHistory[fwHistory.length-1].type !== 'sep') {
             // Logic handled below: we add separator BEFORE adding the word of the new perek
        }
    }

    fwHistory.push({ type: 'word', text: word, p: pIdx, m: mIdx });

    // Prepare next index
    if (mIdx < tractate[pIdx].length - 1) {
        mIdx++;
    } else {
        // End of Perek
        if (pIdx < tractate.length - 1) {
            pIdx++;
            mIdx = 0;
            // Add separator for the NEXT click
            fwHistory.push({ type: 'sep', label: `------ ◊§◊®◊ß ${getHebrewLetter(pIdx)} ---------` });
        } else {
            // End of Masechet
            fwHistory.push({ type: 'end', label: 'End of Masechet' });
        }
    }
    updateDisplay();
 }

 function updateDisplay(highlightError = false) {
    const area = document.getElementById('display-area');
    area.innerHTML = "";
    const scrollContainer = document.getElementById('main-scroll-container');

    // --- FIRST WORD MODE RENDER ---
    if (isFirstWordMode) {
        document.getElementById('instructions').innerText = content[currentLang].steps.FW;
        document.getElementById('sub-instructions').innerText = content[currentLang].subs.FW;
        document.getElementById('status').innerText = `${currentLang === 'en' ? currentTractateName : currentTractateHebrew} Perek ${getHebrewLetter(pIdx)}`;
        document.getElementById('progress-pips').innerHTML = ""; // Hide pips in this mode

        const container = document.createElement('div');
        container.className = 'fw-container';

        fwHistory.forEach(item => {
            const div = document.createElement('div');
            if (item.type === 'word') {
                div.className = 'fw-item';
                div.innerText = item.text;
            } else if (item.type === 'sep' || item.type === 'end') {
                div.className = 'fw-separator';
                div.innerHTML = `<span>${item.label}</span>`;
            }
            container.appendChild(div);
        });

        // HINT LOGIC FOR FW MODE
        if (showHint && tractate[pIdx] && tractate[pIdx][mIdx]) {
            const nextWord = tractate[pIdx][mIdx].sentences[0].words[0];
            const hintDiv = document.createElement('div');
            hintDiv.className = 'fw-item hint-word';
            hintDiv.innerText = nextWord.charAt(0) + "...";
            container.appendChild(hintDiv);
        }

        area.appendChild(container);
        setTimeout(() => { scrollContainer.scrollTop = scrollContainer.scrollHeight; }, 30);
        return;
    }

    // --- STANDARD MODE RENDER ---
    if (!tractate.length) return;
    const curM = tractate[pIdx][mIdx];
    const curS = curM.sentences[sIdx];

    if (isLoopMode) {
        document.getElementById('instructions').innerText = currentLang === 'en' ? "Entire Mishnah Loop" : "◊ó◊ñ◊®◊î ◊¢◊ú ◊î◊û◊©◊†◊î";
        document.getElementById('sub-instructions').innerText = currentLang === 'en' ? "Continuous Review" : "◊ó◊ñ◊®◊î ◊®◊¶◊ô◊§◊î";
    } else {
        document.getElementById('instructions').innerText = content[currentLang].steps[displayState];
        document.getElementById('sub-instructions').innerText = content[currentLang].subs[displayState];
    }
    
    document.getElementById('status').innerText = `${currentLang === 'en' ? currentTractateName : currentTractateHebrew} ${pIdx+1}:${mIdx+1}`;
    updatePips(curM.sentences.length);

    if (displayState === "CHUNKS") {
        area.className = "chunk-mode"; area.innerText = curS.chunks[cIdx];
    } else if (displayState === "FULL_SENTENCE") {
        area.className = "chunk-mode"; area.innerText = curS.words.join(' ');
    } else if (displayState === "SENTENCE_REVIEW" || displayState === "CUMULATIVE_REVIEW") {
        area.className = "full-mode";
        const allWords = (displayState === "SENTENCE_REVIEW") ? 
            curS.words : 
            [].concat(...curM.sentences.slice(0, sIdx + 1).map(s => s.words));
        const confirmedWords = allWords.slice(0, wIdx + 1);

        confirmedWords.forEach((w, i) => {
            const span = document.createElement('span');
            span.className = "word" + (highlightError && i === confirmedWords.length-1 ? " wrong-word" : "");
            span.innerText = w; area.appendChild(span);
        });

        if (showHint && wIdx < allWords.length - 1) {
            const nextWord = allWords[wIdx + 1];
            if (nextWord) {
                const hintSpan = document.createElement('span');
                hintSpan.className = "word hint-word";
                hintSpan.innerText = nextWord.charAt(0) + "...";
                area.appendChild(hintSpan);
            }
        }

    } else if (displayState === "CORRECTING") {
        area.className = "full-mode";
        const targetWords = curM.sentences[correctionSentenceIdx].words;
        targetWords.slice(0, wIdx + 1).forEach((w, i) => {
            const span = document.createElement('span'); span.innerText = w;
            span.className = 'word'; if (i === correctionTarget) span.style.color = 'var(--success)';
            area.appendChild(span);
        });
    }

    setTimeout(() => { scrollContainer.scrollTop = scrollContainer.scrollHeight; }, 30);
 }

 function loadFullBartenura(p, m) {
    const box = document.getElementById('bart-container');
    const contentArea = document.getElementById('bart-content');
    if (!bartenuraData) { box.style.display = 'none'; return; }
    
    const cSplit = bartenuraData.split(new RegExp(`Chapter\\s+${p + 1}`, 'i'));
    if (cSplit.length < 2) { box.style.display = 'none'; return; }
    const mSplit = cSplit[1].split(new RegExp(`Mishnah\\s+${m + 1}`, 'i'));
    if (mSplit.length < 2) { box.style.display = 'none'; return; }
    
    let rawMText = mSplit[1].split(/Mishnah\s+\d+|Chapter\s+\d+/i)[0].trim();

    if (rawMText) {
        const parts = rawMText.split(/(?=<b>)/g);
        contentArea.innerHTML = parts.map(part => {
            const boldMatch = part.match(/<b>(.*?)<\/b>/);
            if (boldMatch) {
                const boldPart = boldMatch[0];
                const rest = part.replace(boldPart, "");
                return `<span class="bart-segment">${boldPart}<span class="explanation">${rest}</span></span>`;
            }
            return `<span class="bart-segment"><span class="explanation">${part}</span></span>`;
        }).join('');
        box.style.display = 'block'; box.scrollTop = 0;
    } else { box.style.display = 'none'; }
 }

 function parseTractate(text) {
 const hideRefs = document.getElementById('hide-refs').checked;
 const refRegex = /\([\u0590-\u05FF\s0-9"']+\)/g;
 const perekBlocks = text.split(/\n\s*\n/); 
 tractate = perekBlocks.map(block => {
 const lines = block.split('\n').map(l => l.trim()).filter(l => l && !(l.includes("◊û◊©◊†◊î") && l.length < 20));
 return lines.map(mText => {
 let cleanText = hideRefs ? mText.replace(refRegex, "") : mText;
 const sentences = cleanText.split(/([.:?])/).reduce((acc, val, i) => {
 if (i % 2 === 0 && val.trim()) {
 const cleanStr = val.trim();
 const words = cleanStr.split(/\s+/).filter(w => w.length > 0);
 const chunks = cleanStr.split(/([,;])+/).reduce((cAcc, cVal, cI, cArr) => {
 if (cI % 2 === 0 && cVal.trim()) cAcc.push(cVal.trim() + (cArr[cI+1] || ""));
 return cAcc;
 }, []);
 acc.push({ words, chunks, hasInternalBreaks: chunks.length > 1 });
 }
 return acc;
 }, []);
 return { sentences };
 });
 }).filter(p => p.length > 0);
 }

 function advanceMishnahPosition() {
    const curM = tractate[pIdx][mIdx];
    if (sIdx < curM.sentences.length - 1) {
        sIdx++; cIdx = 0; wIdx = -1;
        displayState = curM.sentences[sIdx].hasInternalBreaks ? "CHUNKS" : "FULL_SENTENCE";
    } else {
        if (mIdx < tractate[pIdx].length - 1) resetToPosition(pIdx, mIdx+1);
        else if (pIdx < tractate.length -1) resetToPosition(pIdx + 1, 0);
    }
 }

 function resetToPosition(p, m) { 
    pIdx = p; mIdx = m; sIdx = 0; cIdx = 0; wIdx = -1; showHint = false;
    isLoopMode = false; document.getElementById('loop-btn').classList.remove('active-mode');
    if(isFirstWordMode) {
        // If in FW mode and we manually reset, stay in FW mode but clear history? 
        // Or exit FW mode? Usually reset means reset logic. Let's reset the FW Perek.
        fwHistory = []; // Clear for new start
    }
    if (tractate[pIdx] && tractate[pIdx][mIdx]) {
        displayState = tractate[pIdx][mIdx].sentences[0].hasInternalBreaks ? "CHUNKS" : "FULL_SENTENCE";
        loadFullBartenura(p, m);
    }
    updateDisplay(); 
 }

 // --- MODE TOGGLES ---
 function toggleLoopMode(e) {
    if(e) e.stopPropagation();
    isLoopMode = !isLoopMode;
    isFirstWordMode = false; document.getElementById('fw-btn').classList.remove('active-mode'); // Disable other mode
    const btn = document.getElementById('loop-btn');
    if (isLoopMode) {
        btn.classList.add('active-mode');
        const curM = tractate[pIdx][mIdx];
        sIdx = curM.sentences.length - 1; wIdx = -1; displayState = "CUMULATIVE_REVIEW";
        updateDisplay();
    } else {
        btn.classList.remove('active-mode');
        resetToPosition(pIdx, mIdx);
    }
 }

 function toggleFirstWordMode(e) {
    if(e) e.stopPropagation();
    isFirstWordMode = !isFirstWordMode;
    isLoopMode = false; document.getElementById('loop-btn').classList.remove('active-mode'); // Disable other mode
    const btn = document.getElementById('fw-btn');
    
    if (isFirstWordMode) {
        btn.classList.add('active-mode');
        // Start at beginning of CURRENT Perek
        mIdx = 0; 
        fwHistory = []; 
        document.getElementById('bart-container').style.display = 'none'; // Hide bartenura in this mode
        updateDisplay();
    } else {
        btn.classList.remove('active-mode');
        resetToPosition(pIdx, 0);
    }
 }

 function openNav() { document.getElementById('nav-modal').style.display = "flex"; resetNavToMasechet(); }
 function closeNav() { document.getElementById('nav-modal').style.display = "none"; }
 function resetNavToMasechet() { document.getElementById('step-masechet').classList.remove('hidden'); document.getElementById('step-perek').classList.add('hidden'); document.getElementById('step-mishnah').classList.add('hidden'); renderMasechetList(""); }
 function backToMasechet() { resetNavToMasechet(); }
 function backToPerek() { document.getElementById('step-mishnah').classList.add('hidden'); document.getElementById('step-perek').classList.remove('hidden'); }
 function renderMasechetList(f) { const c = document.getElementById('masechet-list'); c.innerHTML = ""; masechtotData.forEach(m => { if(m.en.toLowerCase().includes(f) || m.he.includes(f)) { const d = document.createElement('div'); d.className='list-item'; d.innerHTML=`<span>${m.he}</span><span>${m.en}</span>`; d.onclick=()=>selectMasechet(m); c.appendChild(d); } }); }
 
 async function selectMasechet(m) { 
 const r = await fetch(`./Clean_Mishnah/${m.file}.txt`); 
 rawTextCache = await r.text(); 
 parseTractate(rawTextCache); 
 const b = await fetch(`./Bartenura/Bartenura_${m.file}.txt`);
 bartenuraData = b.ok ? await b.text() : "";
 currentTractateName = m.en; currentTractateHebrew = m.he; 
 document.getElementById('step-masechet').classList.add('hidden'); 
 document.getElementById('step-perek').classList.remove('hidden'); 
 const g = document.getElementById('perek-grid'); g.innerHTML = ""; 
 tractate.forEach((_, i) => { const b = document.createElement('div'); b.className='grid-item'; b.innerText=i+1; b.onclick=()=>selectPerek(i); g.appendChild(b); }); 
 }

 function selectPerek(p) { 
    pIdx = p; 
    document.getElementById('step-perek').classList.add('hidden'); 
    document.getElementById('step-mishnah').classList.remove('hidden'); 
    const g = document.getElementById('mishnah-grid'); g.innerHTML = ""; 
    tractate[pIdx].forEach((_, i) => { const b = document.createElement('div'); b.className='grid-item'; b.innerText=i+1; b.onclick=()=>{ resetToPosition(pIdx, i); closeNav(); }; g.appendChild(b); }); 
 }
 function toggleLanguage() { currentLang = currentLang === 'en' ? 'he' : 'en'; updateDisplay(); }
 function updatePips(total) {
 const container = document.getElementById('progress-pips'); container.innerHTML = "";
 for(let i=0; i<total; i++) {
 const p = document.createElement('div');
 p.className = "pip " + (i < sIdx ? "complete" : (i === sIdx ? "active" : ""));
 container.appendChild(p);
 }
 }
 function handleReset(e) { if (e) e.stopPropagation(); resetToPosition(pIdx, mIdx); }
 function reloadText() { if(rawTextCache) { parseTractate(rawTextCache); resetToPosition(pIdx, mIdx); } }

 function triggerCorrection(e) {
    if (e) e.stopPropagation();
    
    // BACKSPACE LOGIC FOR FIRST WORD MODE
    if (isFirstWordMode) {
        // Reset to start of current Perek
        mIdx = 0;
        // Filter history to remove anything from current Perek, keep previous Pereks
        // Actually simplest behavior requested is "back to start of perek". 
        // We will clear history entirely for this specific perek flow.
        fwHistory = [];
        updateDisplay();
        return;
    }

    if (wIdx < 0 || displayState === "CORRECTING") return;
    returnState = displayState;
    const curM = tractate[pIdx][mIdx];
    if (displayState === "CUMULATIVE_REVIEW") {
        let count = 0;
        for (let i = 0; i <= sIdx; i++) {
            let len = curM.sentences[i].words.length;
            if (wIdx < count + len) {
                correctionSentenceIdx = i;
                correctionTarget = wIdx - count;
                break;
            }
            count += len;
        }
    } else {
        correctionSentenceIdx = sIdx;
        correctionTarget = wIdx;
    }
    updateDisplay(true);
    setTimeout(() => { displayState = "CORRECTING"; wIdx = -1; updateDisplay(); }, 400);
 }

 window.addEventListener('keydown', (e) => {
    if (document.getElementById('nav-modal').style.display === "flex") return;
    
    if (e.key.toLowerCase() === 'h') {
        if (!showHint) {
            showHint = true;
            updateDisplay();
        }
    }
    
    if (e.code === 'Space') { e.preventDefault(); handleAdvance(); }
    if (e.code === 'Backspace') { e.preventDefault(); triggerCorrection(); }
 });
 document.getElementById('masechet-search').addEventListener('input', (e) => renderMasechetList(e.target.value.toLowerCase()));
 </script>
</body>
</html>
